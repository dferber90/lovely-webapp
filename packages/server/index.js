/* eslint-disable no-param-reassign, no-console, import/first */
import "./clean-env";
import React from "react";
import { Application } from "@wa/components";
import Koa from "koa";
import serve from "koa-static";
import Router from "koa-router";
import cookie from "koa-cookie";
import mount from "koa-mount";
import { ServerStyleSheet } from "styled-components";
import { StaticRouter } from "react-router";
import { ApolloProvider, renderToStringWithData } from "react-apollo";
import Loadable from "react-loadable";
import tinyHtml from "tinyhtml";
import uniq from "lodash.uniq";
import flatten from "lodash.flatten";
import pretty from "pretty";
import { Helmet } from "react-helmet";
import { createApolloClient } from "./create-apollo-client";

const app = new Koa();
const router = new Router();

app.use(mount("/assets", serve("assets")));
// serve 404 with no content for assets (instead of falling back to ssr)
app.use(
  mount("/assets", ctx => {
    ctx.status = 404;
  })
);

router.get("/server-side", ctx => {
  ctx.body = '<html>Hello World! <a href="/">Back</a></html>';
});

app.use(serve("static"));

app.use(cookie());

app.use(router.routes());
app.use(router.allowedMethods());

const html = ({ body, styles, cachedData, loadableModules, helmet }) => {
  const appBundle = DEV
    ? "<!-- client-side app bundle omitted in server-development -->"
    : do {
        // eslint-disable-next-line global-require, import/no-unresolved
        const { assetsByChunkName } = require("./stats.json");
        // there is only one entry-point, so we can always include all assets
        // assetsByChunkName does not contain dynamic chunks (generated by
        // import()), it only contains the chunks defined in the webpack config
        const assets = flatten(Object.values(assetsByChunkName));
        assets
          .filter(asset => asset.endsWith(".js"))
          .map(asset => `<script src="/assets/${asset}"></script>`)
          .join("");
      };

  const dataScript = DEV
    ? "<!-- data for rehydration -->"
    : `<script>window.APOLLO_STATE=${JSON.stringify(cachedData)};</script>`;

  // It is important that the bundles are included before the main bundle,
  // so that they can be loaded by the browser prior to the app rendering.
  // However, as the Webpack manifest (including the logic for parsing bundles)
  // lives in the main bundle, it will need to be extracted into its own chunk.
  //  - from https://github.com/jamiebuilds/react-loadable
  const loadableBundles = DEV
    ? "<!-- bundles from code-splitting through react-loadable -->"
    : do {
        // eslint-disable-next-line global-require, import/no-unresolved
        const stats = require("./react-loadable.json");
        // eslint-disable-next-line global-require
        const { getBundles } = require("react-loadable/webpack");
        const bundles = getBundles(stats, loadableModules);

        uniq(bundles.filter(bundle => bundle.file.endsWith(".js")))
          .map(bundle => `<script src="/assets/${bundle.file}"></script>`)
          .join("\n");
      };

  const analyticsSnippet = DEV
    ? "<!-- placeholder for tracking snippet -->"
    : `<!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-46478607-9"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-46478607-9');
        </script>
      `;

  const config = {
    API_ENDPOINT: process.env.API_ENDPOINT
  };

  return `
    <!DOCTYPE html>
    <html ${helmet.htmlAttributes.toString()}>
      <head>
        ${helmet.title.toString()}
        ${helmet.meta.toString()}
        ${helmet.link.toString()}
        ${styles}
        ${analyticsSnippet}
      </head>
      <body ${helmet.bodyAttributes.toString()}>
        <div id="app">${body}</div>
        <script>window.CONFIG=${JSON.stringify(config)};</script>
        ${dataScript}
        ${appBundle}
        ${loadableBundles}
      </body>
    </html>
  `;
};

app.use(async context => {
  const authToken = context.cookie ? context.cookie.authToken : null;
  const apolloClient = createApolloClient(authToken);
  const sheet = new ServerStyleSheet();
  const routingContext = {};
  const modules = [];
  try {
    const body = await renderToStringWithData(
      sheet.collectStyles(
        <Loadable.Capture report={moduleName => modules.push(moduleName)}>
          <ApolloProvider client={apolloClient}>
            <StaticRouter
              location={context.request.url}
              context={routingContext}
            >
              <Application />
            </StaticRouter>
          </ApolloProvider>
        </Loadable.Capture>
      )
    );

    if (routingContext.url) {
      // we use `routingContext.status` by in RedirectWithStatus
      if (routingContext.status) context.status = routingContext.status;
      context.redirect(routingContext.url);
    } else {
      // add 404
      if (routingContext.status) context.status = routingContext.status;
      const styles = sheet.getStyleTags();
      const markup = html({
        body,
        styles,
        cachedData: apolloClient.cache.extract(),
        loadableModules: modules,
        helmet: Helmet.renderStatic()
      });
      context.body = DEV ? pretty(markup) : tinyHtml(markup);
    }
  } catch (e) {
    context.body = `Rendering Error: ${e.stack}`;
  }
});

const port = 3000;

Loadable.preloadAll().then(() => {
  app.listen(port, () =>
    console.log(
      // eslint-disable-line no-console
      `App Server is now running on http://localhost:${port}`
    )
  );
});

if (module.hot) {
  module.hot.accept(() => {
    console.log("received new hm");
  });
}
